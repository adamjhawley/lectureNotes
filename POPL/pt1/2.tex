% Created 2019-02-20 Wed 16:57
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{Adam Hawley}
\date{\today}
\title{Lecture 2: Compilers, Interpreters \& Scheme}
\hypersetup{
 pdfauthor={Adam Hawley},
 pdftitle={Lecture 2: Compilers, Interpreters \& Scheme},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.1 (Org mode 9.2)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents


\section{Compilers}
\label{sec:orgd4f5193}
\emph{``Compilation is file conversion that preserves the semantics of the code''}.
The front end analyses the source code (lexical analysis \& parsing) and builds an intermediate representaion consisting of a data structure or a stack.
\subsection{Back-End of a Compiler}
\label{sec:org3233bb7}
The back-end of a compiler contains several steps:
\begin{itemize}
\item Analysis (data flow, alias analysis\ldots{})
\item Optimisation e.g:
\begin{itemize}
\item Constant folding: \texttt{x := 10 + 20 + 30;}
\item Constant propogation: \texttt{x := 32; y := x / 2}
\item Dead code elimination (unreachable or only changing variables that are never read again).
\end{itemize}
\item Code generation
\end{itemize}
\subsection{Portability of Compiled Programs}
\label{sec:org8f907b3}
\emph{"If the front-end and the back-end are perfectly separate, we only need M front ends (for M source languages) and N back-ends (for N different hardware platforms) to produce M*N compilers."}

This is a nice idea in theory but such a \emph{pure} approach makes the implementation difficult.
A lot of specialised languages compile to the source code which has compilers for most OSs and hardware, e.g C with gcc.
\section{Interpreters}
\label{sec:orgf39c024}
\subsection{Benefits of Interpreters}
\label{sec:orgc3ba5ed}
\begin{description}
\item[{Better Portability}] An interpreter is normally written in a high-level language and is therefore broadly \emph{machine-independent} (unlike compilers which produce \emph{machine-specific} code)/.
\item[{Cheaper}] Writing an interpreter is less work than writing a back-end.
\item[{Better Error Checking \& Reporting}] In the strife for efficiency, compilers may throw away valuable info, e.g source code and line numbers.
\item[{Increased Security (Idk about this\ldots{})}] Checking compiled binaries vs. examining the interpreter (contributed to Java's success)
\item[{Code Generation}] The interpreter can execute new code generated by the running program itself. Output data can become code!
\end{description}

The main trade-off between interpreters and compilers is compilation time vs. execution time trade-off.
\section{Scheme}
\label{sec:org1087e27}
See the lecture for info on scheme.
\end{document}
